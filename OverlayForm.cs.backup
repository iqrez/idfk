using Nefarius.ViGEm.Client.Targets.Xbox360;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Linq;
using System.IO;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using Microsoft.Win32;
using System.Runtime.InteropServices;

namespace WootMouseRemap
{
    public sealed class OverlayForm : Form
    {
        public const string VersionTag = "r27";

        // === Physical controller detection (XInput) ===
        [StructLayout(LayoutKind.Sequential)]
        private struct XINPUT_GAMEPAD
        {
            public ushort wButtons;
            public byte bLeftTrigger;
            public byte bRightTrigger;
            public short sThumbLX;
            public short sThumbLY;
            public short sThumbRX;
            public short sThumbRY;
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct XINPUT_STATE
        {
            public uint dwPacketNumber;
            public XINPUT_GAMEPAD Gamepad;
        }

        [DllImport("xinput1_4.dll", EntryPoint = "XInputGetState")]
        private static extern uint XInputGetState14(uint dwUserIndex, out XINPUT_STATE state);

        [DllImport("xinput1_3.dll", EntryPoint = "XInputGetState")]
        private static extern uint XInputGetState13(uint dwUserIndex, out XINPUT_STATE state);

        private const uint ERROR_SUCCESS = 0;
        private const int WM_DEVICECHANGE = 0x0219;

        private bool _physControllerPresent = false;
        private DateTime _lastControllerActivity = DateTime.MinValue;
        private readonly System.Windows.Forms.Timer _devicePoll = new System.Windows.Forms.Timer { Interval = 1000 };

        private bool AnyXInputControllerPresent()
        {
            try
            {
                // Check all 4 XInput slots for a real controller
                for (uint i = 0; i < 4; i++)
                {
                    XINPUT_STATE state;
                    uint result;
                    try
                    {
                        result = XInputGetState14(i, out state);
                    }
                    catch (DllNotFoundException)
                    {
                        result = XInputGetState13(i, out state);
                    }
                    if (result == ERROR_SUCCESS)
                    {
                        // If any button, trigger, or stick is nonzero, assume a real controller is present
                        if (state.Gamepad.wButtons != 0 ||
                            state.Gamepad.bLeftTrigger != 0 ||
                            state.Gamepad.bRightTrigger != 0 ||
                            state.Gamepad.sThumbLX != 0 ||
                            state.Gamepad.sThumbLY != 0 ||
                            state.Gamepad.sThumbRX != 0 ||
                            state.Gamepad.sThumbRY != 0)
                        {
                            return true;
                        }
                    }
                }
                return false;
            }
            catch
            {
                return false;
            }
        }

        private bool _suppressGuard, _xpassGuard;

        private readonly Xbox360ControllerWrapper _pad;
        private readonly RawInput _raw;
        private readonly RawInputMsgWindow _msgWin;

        private readonly Telemetry _tele = new();
        private readonly ProfileManager _profiles = new();
        private readonly StickMapper _mapper = new();
        private readonly InputRouter _router;

        private long _lastWheelTick;
        private long _lastToggleTick;

        private bool _midDownActive;
        private bool _middleToggleEnabled = true; // Already defaulted to true
        private long _midDownTick;
        private int _midMoveAccum;
        private WootMouseRemap.MouseSettingsBus _mouseBus;
        private WootMouseRemap.MouseSettingsBinder _mouseBinder;

        private readonly MacroEngine _macros;
        private readonly XInputPassthrough _xpass;

        private readonly System.Windows.Forms.Timer _uiTimer = new() { Interval = 16 };
        private readonly System.Windows.Forms.Timer _statusTimer = new() { Interval = 250 };
        private readonly System.Windows.Forms.Timer _submitTimer = new() { Interval = 5 };
        private readonly System.Windows.Forms.Timer _xinputPoll = new() { Interval = 250 };
        private DateTime _lastMouseMoveUtc = DateTime.UtcNow;

        private InputMode _mode = InputMode.ControllerOutput;
        private readonly ModeController _modes = new ModeController("mode.json");
        private bool _dUp, _dDown, _dLeft, _dRight;
        private bool _overlayKeyPhysicalDown;
        private DateTime _lastOverlayToggle = DateTime.MinValue;

        private bool _modCtrlDown, _modShiftDown, _modAltDown;

        // UI
        private readonly TabControl _tabs = new() { Dock = DockStyle.Fill };
        private readonly InputVisualizerControl _viz = new() { Dock = DockStyle.Fill };
        private TableLayoutPanel _dashLayout = new TableLayoutPanel();
        private readonly System.Windows.Forms.Timer _vizTimer = new System.Windows.Forms.Timer { Interval = 33 };

        private enum VizSource { VirtualOutput, PhysicalInput }
        private VizSource _vizSource = VizSource.PhysicalInput;
        private readonly ComboBox _vizSourceSel = new() { Width = 160, DropDownStyle = ComboBoxStyle.DropDownList };

        // === Output suspension for testing/capture ===
        private volatile bool _outputSuspended;
        private int _suspendRefCount;

        private void SuspendRawInput(string reason)
        {
            _suspendRefCount++;
            _outputSuspended = true;
            ZeroOutputs();
        }
        private void ResumeRawInput(string reason)
        {
            if (_suspendRefCount > 0) _suspendRefCount--;
            if (_suspendRefCount == 0) _outputSuspended = false;
        }
        private void ZeroOutputs()
        {
            try
            {
                _pad.SetRightStick(0, 0);
                _pad.SetLeftStick(0, 0);
                _pad.SetTrigger(false, 0);
                _pad.SetTrigger(true, 0);
                foreach (Xbox360Button b in Enum.GetValues(typeof(Xbox360Button)))
                    _pad.SetButton(b, false);
                _pad.Submit();
            }
            catch { }
        }

        private readonly CheckBox _xinputEnable = new() { Text = "Controller Passthrough (Auto XInput)" };
        private ControllerDetector? _detector;
        private bool _autoIndex = true;

        // Controller presence visual
        private readonly Panel _ctlrDot = new() { Width = 12, Height = 12, Margin = new Padding(0, 2, 6, 0) };
        private readonly ToolTip _ctlrTip = new();
        private readonly Label _status = new() { AutoSize = true, Font = new Font(FontFamily.GenericSansSerif, 10, FontStyle.Bold) };
        // The toggle mode button text now reflects both the F8 keyboard shortcut and middle mouse click
        private readonly Button _toggleMode = new() { Text = "Toggle (Desktop/Play)" };
        private readonly CheckBox _suppressChk = new() { Text = "Suppress OS Input (no dual input)" };
        private readonly Label _overlayHotkeyLbl = new() { AutoSize = true };
        private readonly Button _overlayHotkeyBtn = new() { Text = "Set Show/Hide" };
        private readonly Label _modeHotkeyLbl = new() { AutoSize = true };
        private readonly Button _modeHotkeyBtn = new() { Text = "Set Toggle" };
        private readonly Label _suppressHotkeyLbl = new() { AutoSize = true };
        private readonly Button _suppressHotkeyBtn = new() { Text = "Set Suppress" };
        // Streamline: show only master toggle and separate show/hide overlay
        private void HideMergedHotkeysUI()
        {
            _modeHotkeyLbl.Visible = false; _modeHotkeyBtn.Visible = false;
            _suppressHotkeyLbl.Visible = false; _suppressHotkeyBtn.Visible = false;
        }


        private enum HotkeyTarget { None, Overlay, Mode, Suppress }
        private HotkeyTarget _capturingHotkey = HotkeyTarget.None;

        private bool _capturingOverlayKey = false;
        private int _overlayToggleVk = 0xDC; // default '\\'
        private uint _overlayHotkeyMods = 0; // default set later to Ctrl
        private readonly Button _figStart = new() { Text = "Figure-8 Start" };
        private readonly Button _figStop = new() { Text = "Figure-8 Stop" };
        private readonly Button _autoTune = new() { Text = "Auto-Tune (5s)" };
        private readonly NotifyIcon _tray = new() { Visible = true, Text = "WootMouseRemap", Icon = SystemIcons.Application };

        // Global hotkey IDs
        private const int HOTKEY_TOGGLE_MASTER = 100;
        private const int HOTKEY_PANIC = 999; // single master toggle + panic
        private const Keys PANIC_KEY = Keys.Delete; // Use Delete for panic
        private const uint PANIC_MODS = MOD_CONTROL | MOD_ALT; // Ctrl+Alt+Del


        private const string BUILD_TAG = "r50";
        private int _overlayHotkeyRegisteredVk = 0;

        // MOD_* for RegisterHotKey
        private const uint MOD_ALT = 0x0001;
        private const uint MOD_CONTROL = 0x0002;
        private const uint MOD_SHIFT = 0x0004;
        private const uint MOD_WIN = 0x0008;

        // === Win32 interop (single block) ===
        private const int GWL_EXSTYLE = -20;
        private const int WS_EX_TRANSPARENT = 0x00000020;
        private const int WS_EX_LAYERED = 0x00080000;

        [DllImport("user32.dll")] private static extern bool RegisterHotKey(IntPtr hWnd, int id, uint fsModifiers, int vk);
        [DllImport("user32.dll")] private static extern bool UnregisterHotKey(IntPtr hWnd, int id);
        [DllImport("user32.dll")] private static extern int GetWindowLong(IntPtr hWnd, int nIndex);
        [DllImport("user32.dll")] private static extern int SetWindowLong(IntPtr hWnd, int nIndex, int dwNewLong);
        [DllImport("user32.dll")]
        private static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int X, int Y, int cx, int cy, uint uFlags);
        private static readonly IntPtr HWND_TOPMOST = new IntPtr(-1);
        private const uint SWP_NOMOVE = 0x0002;
        private const uint SWP_NOSIZE = 0x0001;
        private const uint SWP_SHOWWINDOW = 0x0040;

        private CancellationTokenSource? _figCts, _tuneCts;

        // Curves
        private readonly NumericUpDown nSens = new() { Minimum = 1, Maximum = 200, Value = 35, DecimalPlaces = 0 };
        private readonly NumericUpDown nExpo = new() { Minimum = 0, Maximum = 100, Value = 60, DecimalPlaces = 0 };
        private readonly NumericUpDown nADZ = new() { Minimum = 0, Maximum = 30, Value = 5, DecimalPlaces = 0 };
        private readonly NumericUpDown nEMA = new() { Minimum = 0, Maximum = 100, Value = 35, DecimalPlaces = 0 };
        private readonly NumericUpDown nVel = new() { Minimum = 0, Maximum = 100, Value = 0, DecimalPlaces = 0 };
        private readonly NumericUpDown nJit = new() { Minimum = 0, Maximum = 50, Value = 0, DecimalPlaces = 0 };
        private readonly NumericUpDown nSX = new() { Minimum = 10, Maximum = 300, Value = 100, DecimalPlaces = 0 };
        private readonly NumericUpDown nSY = new() { Minimum = 10, Maximum = 300, Value = 100, DecimalPlaces = 0 };
        private readonly NumericUpDown nDpi = new() { Minimum = 200, Maximum = 26000, Value = 1600, Increment = 50, Width = 64 };

        // Mapping grids
        private readonly DataGridView gridKeys = new() { Dock = DockStyle.Fill, AutoGenerateColumns = false, AllowUserToAddRows = false };
        private readonly DataGridView gridMouse = new() { Dock = DockStyle.Fill, AutoGenerateColumns = false, AllowUserToAddRows = false };
        private bool _capturing;
        private string _captureTarget = ""; // "K:<vk>" or "M:<button>"

        // Profiles
        private readonly ListBox lstProfiles = new() { Dock = DockStyle.Left, Width = 220 };
        private readonly Button btnLoad = new() { Text = "Load" };
        private readonly Button btnNew = new() { Text = "New" };
        private readonly Button btnClone = new() { Text = "Clone" };
        private readonly Button btnDelete = new() { Text = "Delete" };
        private readonly Button btnSave = new() { Text = "Save" };


        // Error state for overlay display
        private static readonly List<string> _recentErrors = new();
        private static readonly object _errLock = new();
        private static void AddError(string msg)
        {
            lock (_errLock)
            {
                if (_recentErrors.Count > 10) _recentErrors.RemoveAt(0);
                _recentErrors.Add($"[{DateTime.Now:HH:mm:ss}] {msg}");
            }
        }
        public static IReadOnlyList<string> GetRecentErrors()
        {
            lock (_errLock) { return _recentErrors.ToList(); }
        }


        private void UpdateVisualizerRowHeight()
        {
            try
            {
                if (_dashLayout == null) return;
                // Row 1 is the Visualizer group
                const int row = 1;
                float minH = 140f, maxH = 260f;
                int w = _dashLayout.ClientSize.Width > 0 ? _dashLayout.ClientSize.Width : this.ClientSize.Width;
                // Aim for a thin, wide bar; ~14% of width works well; clamp to min/max
                float h = Math.Max(minH, Math.Min(maxH, w * 0.14f));
                _dashLayout.RowStyles[row].SizeType = SizeType.Absolute;
                _dashLayout.RowStyles[row].Height = h;
                _viz.MinimumSize = new Size(0, (int)minH);
                _viz.Invalidate();
            }
            catch { }
        }


        protected override void OnLoad(EventArgs e)
        {
            base.OnLoad(e);
            try { /* mode loaded in constructor */ } catch { }
        }
        private NumericUpDown _xinputIndexUpDown = new NumericUpDown { Minimum = 0, Maximum = 3, Value = 1, Width = 40, TextAlign = HorizontalAlignment.Center };
        public OverlayForm(Xbox360ControllerWrapper pad, RawInput raw, RawInputMsgWindow msgWin)
        {
            try {
                Logger.Info($"OverlayForm started at {DateTime.Now:u}");
                WireHiddenPassthroughBridge();
                this.Text = $"PERFECT — {VersionTag}";

                _ctlrDot.Paint += (s, e) =>
                {
                    e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;
                    using (var b = new SolidBrush(_physControllerPresent ? Color.LimeGreen : Color.IndianRed))
                    using (var p = new Pen(Color.FromArgb(80, Color.Black)))
                    {
                        e.Graphics.Clear(BackColor);
                        e.Graphics.FillEllipse(b, 1, 1, _ctlrDot.Width - 2, _ctlrDot.Height - 2);
                        e.Graphics.DrawEllipse(p, 1, 1, _ctlrDot.Width - 2, _ctlrDot.Height - 2);
                    }
                };
                _ctlrTip.SetToolTip(_ctlrDot, _physControllerPresent ? "Controller detected" : "No controller");

                _pad = pad; _raw = raw; _msgWin = msgWin;
                _macros = new MacroEngine(_pad);
                _xpass = new XInputPassthrough(_pad);

                Text = "WootMouseRemap";
                Width = 980; Height = 640;
                StartPosition = FormStartPosition.CenterScreen;
                FormBorderStyle = FormBorderStyle.None;
                MaximizeBox = false; TopMost = true; Opacity = 1.0;
                this.SetStyle(ControlStyles.AllPaintingInWmPaint | ControlStyles.UserPaint | ControlStyles.OptimizedDoubleBuffer, true);
                this.UpdateStyles();
                this.DoubleBuffered = true;

                _raw.Register();
                _router = new InputRouter(_raw, useHooksMouseFallback: true);


                _mouseBus = new MouseSettingsBus(debounceMs: 20);
                _mouseBinder = new MouseSettingsBinder(this, _mouseBus);
                _mouseBus.Changed += s =>
                {
                    var c = _mapper.Curve;
                    c.ScaleX = s.InvertX ? -s.SensitivityX : s.SensitivityX;
                    c.ScaleY = s.InvertY ? -s.SensitivityY : s.SensitivityY;
                    c.AntiDeadzone = s.Deadzone;
                    c.EmaAlpha = s.Smoothing;
                    c.VelocityGain = s.AccelGain;
                    c.VelocityCap = s.AccelCap;
                    c.Expo = Math.Clamp((s.Gamma - 1f) / 2f, 0f, 1f);
                };
                _mouseBus.ApplyNow(_mouseBus.Current);
                // events
                _router.OnKey += OnKey;
                _router.OnMouseButton += OnMouseButton;
                _router.OnMouseMove += OnMouseMove;
                _router.OnWheel += OnWheel;
                Logger.Info("InputRouter events wired");

                _pad.StatusChanged += Pad_StatusChanged;
                _uiTimer.Tick += (_, __) => { UpdateVisualizer(); _tele.ResetMove(); };
                _statusTimer.Tick += (_, __) => { UpdateStatus(); };
                Logger.Info("UI timers started");
                _uiTimer.Start();
                _xinputPoll.Tick += (_, __) =>
                {
                    bool present = false;
                    try { present = XInputHelper.AnyConnected(); } catch { }
                    if (present != _physControllerPresent)
                    {
                        _physControllerPresent = present;
                        try { _ctlrDot.Invalidate(); } catch { }
                    }
                    if (_mode == InputMode.ControllerPassthrough)
                    {
                        if (present)
                        {
                            if (!_xpass.IsRunning) { try { _xpass.Start(); } catch { } }
                        }
                        else
                        {
                            if (_xpass.IsRunning) { try { _xpass.Stop(); } catch { } }
                        }
                    }
                };
                _xinputPoll.Start();
                _statusTimer.Start();
                // Mode controller hookup
                try
                {
                    _modes.ModeChanged += newMode => { OnModeChanged(_mode, newMode); };
                    // default to MouseKeyboard on first run
                    OnModeChanged(_mode, _modes.Current);
                    Logger.Info($"Initial mode: {_modes.Current}");
                }
                catch { Logger.Warn("Failed to hook ModeChanged event"); }
                _submitTimer.Tick += (_, __) =>
                {
                    // Watchdog: if no mouse movement recently, hard-zero right stick to prevent drift when lifting mouse
                    if (_mode == InputMode.ControllerOutput)
                    {
                        var idleMs = (DateTime.UtcNow - _lastMouseMoveUtc).TotalMilliseconds;
                        if (idleMs > 18) // ~1 frame at 55Hz or safety at high polling rates
                        {
                            _pad.SetRightStick(0, 0);
                            try { _mapper.Curve.ResetSmoothing(); } catch { }
                            Logger.Info("Watchdog: right stick zeroed due to mouse idle");
                        }
                    }
                    _pad.Submit();
                };
                // Ensure suppression reflects initial mode to avoid dual-input on startup
                if (_mode == InputMode.ControllerOutput)
                {
                    LowLevelHooks.Suppress = true;
                    _suppressGuard = true; _xpassGuard = true; _suppressChk.Checked = true; _xpassGuard = false; _suppressGuard = false;
                }
                _submitTimer.Start();


                // Ensure the form can see key presses
                this.KeyPreview = true;
                this.KeyDown += (s, e) =>
                {
                    if (_capturingOverlayKey)
                    {
                        // ESC cancels
                        if (e.KeyCode == Keys.Escape)
                        {
                            ResumeRawInput("HotkeyCapture");
                            _capturingOverlayKey = false;
                            _capturingHotkey = HotkeyTarget.None;
                            _overlayHotkeyBtn.Enabled = _modeHotkeyBtn.Enabled = _suppressHotkeyBtn.Enabled = true;
                            _overlayHotkeyLbl.Text = HotkeyLabel(_profiles.Current.OverlayToggleMods, _profiles.Current.OverlayToggleVk);
                            _modeHotkeyLbl.Text = HotkeyLabel(_profiles.Current.ModeToggleMods, _profiles.Current.ModeToggleVk);
                            _suppressHotkeyLbl.Text = HotkeyLabel(_profiles.Current.SuppressToggleMods, _profiles.Current.SuppressToggleVk);
                            e.Handled = true;
                            return;
                        }

                        // compute mods
                        uint mods = 0;
                        if (e.Control) mods |= MOD_CONTROL;
                        if (e.Alt) mods |= MOD_ALT;
                        if (e.Shift) mods |= MOD_SHIFT;

                        if (e.KeyCode != Keys.ControlKey && e.KeyCode != Keys.Menu && e.KeyCode != Keys.ShiftKey)
                        {
                            var vk = (int)e.KeyCode;
                            var p = _profiles.Current;
                            if (_capturingHotkey == HotkeyTarget.Overlay) { p.OverlayToggleVk = vk; p.OverlayToggleMods = mods; }
                            else if (_capturingHotkey == HotkeyTarget.Mode) { p.ModeToggleVk = vk; p.ModeToggleMods = mods; }
                            else if (_capturingHotkey == HotkeyTarget.Suppress) { p.SuppressToggleVk = vk; p.SuppressToggleMods = mods; }

                            try { _profiles.Save(); } catch { }
                            RegisterAllHotkeysFromProfile();

                            _capturingOverlayKey = false;
                            _capturingHotkey = HotkeyTarget.None;
                            _overlayHotkeyBtn.Enabled = _modeHotkeyBtn.Enabled = _suppressHotkeyBtn.Enabled = true;
                            ResumeRawInput("HotkeyCapture");
                            e.Handled = true;
                        }
                    }
                };
                // hotkeys
                _overlayHotkeyMods = 0; // default to Ctrl
                RegisterAllHotkeysFromProfile();


                // tray
                var cm = new ContextMenuStrip();
                // Update context menu text to reflect that middle mouse can also toggle the mode
                _ = cm.Items.Add("Toggle (Desktop/Play)", null, (_, __) => ToggleMaster());

                _ = cm.Items.Add("(merged) (Ctrl+F9)", null, (_, __) => ToggleSuppress());
                _ = cm.Items.Add("Show/Hide Overlay", null, (_, __) => ToggleOverlayVisible());
                cm.Items.Add(new ToolStripSeparator());
                var mStartWithWindows = new ToolStripMenuItem("Start with Windows") { Checked = IsStartupEnabled(), CheckOnClick = true };
                mStartWithWindows.CheckedChanged += (_, __) => SetStartupEnabled(mStartWithWindows.Checked);
                cm.Items.Add(mStartWithWindows);
                cm.Items.Add(new ToolStripSeparator());
                cm.Items.Add("Open Logs", null, (_, __) => System.Diagnostics.Process.Start("explorer.exe", "Logs"));
                cm.Items.Add("Exit", null, (_, __) => Close());
                _tray.ContextMenuStrip = cm;


                _tabs.Multiline = false; _tabs.Appearance = TabAppearance.Normal; _tabs.SizeMode = TabSizeMode.Normal;
                BuildTabs();
                Controls.Add(_tabs);

                ApplyProfileToUI();
                RegisterAllHotkeysFromProfile();
                UpdateStatus();
                HideMergedHotkeysUI();
            } catch (Exception ex) { Logger.Error("OverlayForm ctor error", ex); AddError($"OverlayForm ctor: {ex.Message}"); }
        }
        private void OnControllerConnectionChanged(bool connected, int index)
        {
            _physControllerPresent = connected;
            try { _ctlrDot.Invalidate(); } catch { }

            // Sync index spinner under guard
            bool guard = _xpassGuard; _xpassGuard = true;
            try { _xinputIndexUpDown.Value = index; } catch { }
            finally { _xpassGuard = guard; }

            // Always update the passthrough player index when detector finds a new active controller
            try { _xpass.SetPlayerIndex(index); } catch { }

            if (_mode == InputMode.ControllerPassthrough)
            {
                if (!connected)
                {
                    // No controller connected - switch to Controller Output mode
                    try { _modes.Apply(InputMode.ControllerOutput); } catch { }
                    try
                    {
                        _tray.BalloonTipTitle = "WootMouseRemap";
                        _tray.BalloonTipText = "Controller disconnected — switched to Play (Controller Output)";
                        _tray.ShowBalloonTip(1500);
                    }
                    catch { }
                    try { _xpass.Stop(); } catch { }
                }
                else
                {
                    // Controller connected - ensure passthrough is running with correct index
                    try 
                    { 
                        _xpass.SetPlayerIndex(index); 
                        if (!_xpass.IsRunning) 
                            _xpass.Start(); 
                    } 
                    catch { }
                    try
                    {
                        _tray.BalloonTipTitle = "WootMouseRemap";
                        _tray.BalloonTipText = $"Controller connected at P{index + 1} — Passthrough active";
                        _tray.ShowBalloonTip(1200);
                    }
                    catch { }
                }
            }
            else if (connected && _mode == InputMode.ControllerOutput)
            {
                // If we're in controller output mode and a controller connects, 
                // make sure the passthrough knows about the correct index for potential future use
                try { _xpass.SetPlayerIndex(index); } catch { }
            }

            UpdateStatus();
            UpdateToggleButtonText();
        }


        // ---------- Safe UI invoke to avoid handle races ----------
        private void UiInvoke(Action a)
        {
            if (IsDisposed) return;
            try
            {
                if (InvokeRequired)
                {
                    if (!IsHandleCreated) return;
                    BeginInvoke(a);
                }
                else
                {
                    a();
                }
            }
            catch { /* ignore during shutdown */ }
        }

        private void Pad_StatusChanged(bool ok) => UiInvoke(UpdateStatus);

        // ===== UI Build =====
        private void BuildTabs()
        // Removed duplicate BuildTabs declaration
        {
            _tabs.TabPages.Clear();

            // Dashboard

            // Dashboard (styled)
            var tabDash = new TabPage("Dashboard");
            tabDash.Padding = new Padding(12);

            // overall vertical layout
            _dashLayout = new TableLayoutPanel
            {
                Dock = DockStyle.Fill,
                ColumnCount = 1,
                RowCount = 3,
                AutoSize = true,
                AutoSizeMode = AutoSizeMode.GrowAndShrink
            };
            // Define row styles so the visualizer row has a fixed height and other rows autosize
            _dashLayout.RowStyles.Clear();
            _dashLayout.RowStyles.Add(new RowStyle(SizeType.AutoSize));           // 0: status
            _dashLayout.RowStyles.Add(new RowStyle(SizeType.Percent, 100));     // 1: visualizer
            _dashLayout.RowStyles.Add(new RowStyle(SizeType.AutoSize));          // 2: controls row
            _dashLayout.RowStyles.Add(new RowStyle(SizeType.AutoSize));          // 3: hotkeys/testing row
            _dashLayout.RowStyles.Add(new RowStyle(SizeType.AutoSize));          // 4: curves
            _dashLayout.RowStyles.Add(new RowStyle(SizeType.AutoSize));          // 5: mappings
            _dashLayout.RowStyles.Add(new RowStyle(SizeType.AutoSize));          // 6: profiles

            _dashLayout.ColumnStyles.Add(new ColumnStyle(SizeType.Percent, 100));

            // status strip
            _status.AutoSize = true;
            _status.Margin = new Padding(0, 0, 0, 8);
            _dashLayout.Controls.Add(_status, 0, 0);
            // Visualizer (always visible at top, below status)
            var grpViz = new GroupBox { Text = "Visualizer", Dock = DockStyle.Fill, Padding = new Padding(6) };
            var vizHost = new Panel { Dock = DockStyle.Fill };
            _viz.BackColor = System.Drawing.Color.FromArgb(18, 18, 18);
            _viz.Margin = new Padding(0);
            vizHost.BorderStyle = BorderStyle.FixedSingle;
            _viz.Dock = DockStyle.Fill;
            vizHost.BackColor = System.Drawing.Color.FromArgb(18, 18, 18);
            vizHost.Controls.Add(_viz);
            grpViz.Controls.Add(vizHost);
            _dashLayout.Controls.Add(grpViz, 0, 1);
            _dashLayout.RowCount = Math.Max(_dashLayout.RowCount, 2);
            // Controls row: Toggle + Suppress + XInput group
            var ctrlRow = new TableLayoutPanel
            {
                Dock = DockStyle.Top,
                ColumnCount = 4,
                AutoSize = true,
                AutoSizeMode = AutoSizeMode.GrowAndShrink
            };
            ctrlRow.ColumnStyles.Add(new ColumnStyle(SizeType.AutoSize)); // toggle
            ctrlRow.ColumnStyles.Add(new ColumnStyle(SizeType.AutoSize)); // suppress
            ctrlRow.ColumnStyles.Add(new ColumnStyle(SizeType.AutoSize)); // xinput
            ctrlRow.ColumnStyles.Add(new ColumnStyle(SizeType.AutoSize)); // controller

            _toggleMode.AutoSize = true;
            _toggleMode.MinimumSize = new Size(140, 28);
            _toggleMode.Margin = new Padding(0, 0, 12, 0);
            _toggleMode.Click += (_, __) => ToggleMaster();
            ctrlRow.Controls.Add(_toggleMode, 0, 0);

            _suppressChk.AutoSize = true;
            _suppressChk.Margin = new Padding(0, 4, 24, 0);
            _suppressChk.CheckedChanged += (_, __) =>
            {
                if (_suppressGuard || _xpassGuard) return;
                LowLevelHooks.Suppress = _suppressChk.Checked;
                UpdateStatus();
            };
            ctrlRow.Controls.Add(_suppressChk, 1, 0);

            var xinputPanel = new FlowLayoutPanel { Dock = DockStyle.Top, AutoSize = true, AutoSizeMode = AutoSizeMode.GrowAndShrink, FlowDirection = FlowDirection.LeftToRight, WrapContents = true, Padding = new Padding(0), Margin = new Padding(0, 4, 0, 0) };
            var dpiLbl = new Label { Text = "DPI:", AutoSize = true, Margin = new Padding(16, 6, 6, 0) };
            xinputPanel.Controls.Add(dpiLbl);
            xinputPanel.Controls.Add(nDpi);
            nDpi.ValueChanged += (_, __) => { _profiles.Current.MouseDpi = (int)nDpi.Value; _profiles.Save(); UpdateStatus(); };
            _xinputEnable.AutoSize = true;
            xinputPanel.Controls.Add(_xinputEnable);
            // Add NumericUpDown for XInput index selection
            xinputPanel.Controls.Add(_xinputIndexUpDown);
            _xinputIndexUpDown.Value = 1; // Default to P2 (Player 2) for controller passthrough
            _xinputIndexUpDown.ValueChanged += (_, __) =>
            {
                if (_xpassGuard) return;
                
                int newIndex = (int)_xinputIndexUpDown.Value;
                
                // Update the detector to use the manually selected index
                if (_detector != null)
                {
                    _detector.SetIndex(newIndex);
                }
                
                // If we're currently in passthrough mode, update the passthrough immediately
                if (_mode == InputMode.ControllerPassthrough)
                {
                    try
                    {
                        _xpass.SetPlayerIndex(newIndex);
                        
                        // Restart passthrough with new index if it's running
                        if (_xpass.IsRunning)
                        {
                            _xpass.Stop();
                            if (XInputHelper.IsConnected(newIndex))
                            {
                                _xpass.Start();
                                try
                                {
                                    _tray.BalloonTipTitle = "WootMouseRemap";
                                    _tray.BalloonTipText = $"Switched to controller P{newIndex + 1}";
                                    _tray.ShowBalloonTip(1000);
                                }
                                catch { }
                            }
                            else
                            {
                                try
                                {
                                    _tray.BalloonTipTitle = "WootMouseRemap";
                                    _tray.BalloonTipText = $"No controller at P{newIndex + 1} — passthrough stopped";
                                    _tray.ShowBalloonTip(1200);
                                }
                                catch { }
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        AddError($"Failed to switch to controller index {newIndex}: {ex.Message}");
                    }
                }
            };
            _xinputEnable.CheckedChanged += (_, __) => { if (_xpassGuard) return; if (_xinputEnable.Checked) _modes.Apply(InputMode.ControllerPassthrough); else if (_mode == InputMode.ControllerPassthrough) _modes.Apply(InputMode.ControllerOutput); };

            // Controller detector: auto-detect plug/unplug and active slot
            try
            {
                // Default to P2 (index 1) for controller passthrough
                _detector = new ControllerDetector(startIndex: 1, autoIndex: true, periodMs: 500);
                _detector.ConnectionChanged += OnControllerConnectionChanged;
                _xinputIndexUpDown.Value = _detector.Index;
                
                // Disable XInputPassthrough auto-index since ControllerDetector will manage it
                _xpass.SetAutoIndex(false);
                
                // Ensure XInputPassthrough defaults to P2 (index 1)
                _xpass.SetPlayerIndex(1);
            }
            catch { }

            // Detector index is updated by the unified ValueChanged handler above.
            ctrlRow.Controls.Add(xinputPanel, 2, 0);
            var ctlrPanel = new FlowLayoutPanel { FlowDirection = FlowDirection.LeftToRight, AutoSize = true, AutoSizeMode = AutoSizeMode.GrowAndShrink };
            var ctlrLbl = new Label { Text = "Controller", AutoSize = true, Margin = new Padding(0, 6, 6, 0) };
            ctlrPanel.Controls.Add(ctlrLbl);
            ctlrPanel.Controls.Add(_ctlrDot);
            ctrlRow.Controls.Add(ctlrPanel, 3, 0);

            _dashLayout.Controls.Add(ctrlRow, 0, 2);

            // Two group boxes: Hotkeys and Testing
            var groupRow = new TableLayoutPanel { Dock = DockStyle.Top, ColumnCount = 2, AutoSize = true, AutoSizeMode = AutoSizeMode.GrowAndShrink };
            groupRow.ColumnStyles.Add(new ColumnStyle(SizeType.Percent, 60));
            groupRow.ColumnStyles.Add(new ColumnStyle(SizeType.Percent, 40));

            var grpHotkeys = new GroupBox { Text = "Hotkeys", Dock = DockStyle.Fill, Padding = new Padding(6) };
            var hk = new TableLayoutPanel { Dock = DockStyle.Fill, ColumnCount = 2, AutoSize = true };
            hk.ColumnStyles.Add(new ColumnStyle(SizeType.Percent, 70));
            hk.ColumnStyles.Add(new ColumnStyle(SizeType.Percent, 30));

            _overlayHotkeyLbl.Text = HotkeyLabel(_profiles.Current.OverlayToggleMods, _profiles.Current.OverlayToggleVk);
            _overlayHotkeyLbl.AutoSize = true;
            _overlayHotkeyBtn.Text = "Set Toggle";
            _overlayHotkeyBtn.AutoSize = true;
            _overlayHotkeyBtn.Click += (_, __) => { SuspendRawInput("HotkeyCapture"); _capturingOverlayKey = true; _capturingHotkey = HotkeyTarget.Overlay; _overlayHotkeyLbl.Text = "Press a key (mods+key)"; _overlayHotkeyBtn.Enabled = false; this.Focus(); };
            hk.Controls.Add(_overlayHotkeyLbl, 0, 0);
            hk.Controls.Add(_overlayHotkeyBtn, 1, 0);

            _modeHotkeyLbl.Text = HotkeyLabel(_profiles.Current.ModeToggleMods, _profiles.Current.ModeToggleVk);
            _modeHotkeyLbl.AutoSize = true;
            _modeHotkeyBtn.Text = "Set Mode";
            _modeHotkeyBtn.AutoSize = true;
            _modeHotkeyBtn.Click += (_, __) => { SuspendRawInput("HotkeyCapture"); _capturingOverlayKey = true; _capturingHotkey = HotkeyTarget.Mode; _modeHotkeyLbl.Text = "Press a key (mods+key)"; _modeHotkeyBtn.Enabled = false; this.Focus(); };
            hk.Controls.Add(_modeHotkeyLbl, 0, 1);
            hk.Controls.Add(_modeHotkeyBtn, 1, 1);

            _suppressHotkeyLbl.Text = HotkeyLabel(_profiles.Current.SuppressToggleMods, _profiles.Current.SuppressToggleVk);
            _suppressHotkeyLbl.AutoSize = true;
            _suppressHotkeyBtn.Text = "Set Suppress";
            _suppressHotkeyBtn.AutoSize = true;
            _suppressHotkeyBtn.Click += (_, __) => { SuspendRawInput("HotkeyCapture"); _capturingOverlayKey = true; _capturingHotkey = HotkeyTarget.Suppress; _suppressHotkeyLbl.Text = "Press a key (mods+key)"; _suppressHotkeyBtn.Enabled = false; this.Focus(); };
            hk.Controls.Add(_suppressHotkeyLbl, 0, 2);
            hk.Controls.Add(_suppressHotkeyBtn, 1, 2);

            // Middle-mouse toggle checkbox
            var chkMidToggle = new CheckBox { Text = "Middle Mouse toggles mode", AutoSize = true, Checked = _middleToggleEnabled };
            chkMidToggle.CheckedChanged += (_, __) => { _middleToggleEnabled = chkMidToggle.Checked; };
            hk.Controls.Add(new Label { Text = "", AutoSize = true }, 0, 3);
            hk.Controls.Add(chkMidToggle, 1, 3);
            grpHotkeys.Controls.Add(hk);
            groupRow.Controls.Add(grpHotkeys, 0, 0);

            var grpTest = new GroupBox { Text = "Testing", Dock = DockStyle.Fill, Padding = new Padding(6) };
            var tp = new FlowLayoutPanel { Dock = DockStyle.Fill, AutoSize = true, AutoSizeMode = AutoSizeMode.GrowAndShrink };
            _figStart.AutoSize = _figStop.AutoSize = _autoTune.AutoSize = true;
            _figStart.MinimumSize = _figStop.MinimumSize = _autoTune.MinimumSize = new Size(100, 28);
            tp.Controls.Add(_figStart);
            tp.Controls.Add(_figStop);
            tp.Controls.Add(_autoTune);

            // Directions & Tips button
            var btnHelp = new Button { Text = "Directions && Tips", AutoSize = true, MinimumSize = new Size(130, 28) };
            btnHelp.Click += (_, __) => ShowTips();
            tp.Controls.Add(btnHelp);
            grpTest.Controls.Add(tp);
            groupRow.Controls.Add(grpTest, 1, 0);

            _dashLayout.Controls.Add(groupRow, 0, 3);

            tabDash.Controls.Add(_dashLayout);
            UpdateVisualizerRowHeight();
            this.Resize += (_, __) => UpdateVisualizerRowHeight();
            _dashLayout.Resize += (_, __) => UpdateVisualizerRowHeight();

            // ==== Consolidated groups on Dashboard ====
            // Curves group
            var grpCurves = new GroupBox { Text = "Curves", Dock = DockStyle.Top, Padding = new Padding(6), AutoSize = true, AutoSizeMode = AutoSizeMode.GrowAndShrink };
            var curvesPanel = new Panel { Dock = DockStyle.Top, AutoSize = true, AutoSizeMode = AutoSizeMode.GrowAndShrink, Height = 120 };

            // compact two-column layout for curves
            var leftXLabel = 12; var leftXInput = 180;
            var colW = 360;
            var rowH = 26;
            int ci = 0;
            void AddPair2Col(string label, NumericUpDown input)
            {
                int col = ci % 2;
                int row = ci / 2;
                int xLabel = leftXLabel + col * colW;
                int xInput = leftXInput + col * colW;
                int yPos = 12 + row * rowH;
                var l = new Label { Text = label, Location = new Point(xLabel, yPos + 4), AutoSize = true };
                input.Location = new Point(xInput, yPos); input.Width = 56;
                curvesPanel.Controls.Add(l); curvesPanel.Controls.Add(input);
                ci++;
            }
            AddPair2Col("Sensitivity (x/100)", nSens);
            AddPair2Col("Expo (x/100)", nExpo);
            AddPair2Col("AntiDeadzone (x/100)", nADZ);
            AddPair2Col("EMA Alpha (x/100)", nEMA);
            AddPair2Col("Velocity Gain (x/100)", nVel);
            AddPair2Col("Jitter Floor (x/100)", nJit);
            AddPair2Col("Scale X (x/100)", nSX);
            AddPair2Col("Scale Y (x/100)", nSY);
            grpCurves.Controls.Add(curvesPanel);
            _dashLayout.Controls.Add(grpCurves, 0, 4);
            _dashLayout.RowCount = Math.Max(_dashLayout.RowCount, 6);

            // Mappings group
            var grpMap = new GroupBox { Text = "Mappings", Dock = DockStyle.Top, Padding = new Padding(6), AutoSize = true, AutoSizeMode = AutoSizeMode.GrowAndShrink };
            var splitMap = new SplitContainer { Dock = DockStyle.Fill, Orientation = Orientation.Horizontal, SplitterDistance = 280 };
            BuildKeyGrid(); BuildMouseGrid();
            splitMap.Panel1.Controls.Add(gridKeys);
            splitMap.Panel2.Controls.Add(gridMouse);
            grpMap.Controls.Add(splitMap);
            grpMap.Height = 520;
            _dashLayout.Controls.Add(grpMap, 0, 5);
            _dashLayout.RowCount = Math.Max(_dashLayout.RowCount, 6);

            // Profiles group
            var grpProf = new GroupBox { Text = "Profiles", Dock = DockStyle.Top, Padding = new Padding(6), AutoSize = true, AutoSizeMode = AutoSizeMode.GrowAndShrink };
            var profRow = new TableLayoutPanel { Dock = DockStyle.Top, ColumnCount = 3, AutoSize = true, AutoSizeMode = AutoSizeMode.GrowAndShrink };
            profRow.ColumnStyles.Add(new ColumnStyle(SizeType.Percent, 60));
            profRow.ColumnStyles.Add(new ColumnStyle(SizeType.Percent, 40));
            profRow.ColumnStyles.Add(new ColumnStyle(SizeType.AutoSize));
            var cmbProfiles = new ComboBox { DropDownStyle = ComboBoxStyle.DropDownList, Width = 260 };
            cmbProfiles.Items.AddRange(_profiles.ListProfiles().ToArray());
            if (cmbProfiles.Items.Count > 0) {
                int idx = cmbProfiles.Items.IndexOf(_profiles.CurrentPath);
                if (idx >= 0 && idx < cmbProfiles.Items.Count)
                    cmbProfiles.SelectedIndex = idx;
            }
            var pnlBtns = new FlowLayoutPanel { FlowDirection = FlowDirection.LeftToRight, AutoSize = true, AutoSizeMode = AutoSizeMode.GrowAndShrink };
            var btnLoad = new Button { Text = "Load" };
            var btnSave = new Button { Text = "Save" };
            var btnNew = new Button { Text = "New" };
            var btnClone = new Button { Text = "Clone" };
            var btnDel = new Button { Text = "Delete" };
            var btnOpen = new Button { Text = "Open Folder" };
            foreach (var b in new[] { btnLoad, btnSave, btnNew, btnClone, btnDel, btnOpen }) { b.AutoSize = true; b.MinimumSize = new Size(72, 24); }
            pnlBtns.Controls.AddRange(new Control[] { btnLoad, btnSave, btnNew, btnClone, btnDel, btnOpen });
            profRow.Controls.Add(cmbProfiles, 0, 0);
            profRow.SetColumnSpan(cmbProfiles, 2);
            profRow.Controls.Add(pnlBtns, 2, 0);
            grpProf.Controls.Add(profRow);
            // Wire actions
            btnLoad.Click += (_, __) => { if (cmbProfiles.SelectedItem is string pth) { _profiles.Load(pth); ApplyProfileToUI(); RegisterAllHotkeysFromProfile(); } };
            btnSave.Click += (_, __) => { PullUIToProfile(); _profiles.Save(); };
            btnNew.Click += (_, __) => { var path = _profiles.Create("profile"); cmbProfiles.Items.Add(path); cmbProfiles.SelectedItem = path; };
            btnClone.Click += (_, __) => { var path = _profiles.Clone(_profiles.CurrentPath); cmbProfiles.Items.Add(path); cmbProfiles.SelectedItem = path; };
            btnDel.Click += (_, __) => { if (cmbProfiles.SelectedItem is string pth) { _profiles.Delete(pth); cmbProfiles.Items.Remove(pth); if (cmbProfiles.Items.Count > 0) cmbProfiles.SelectedIndex = 0; } };
            btnOpen.Click += (_, __) => { try { Process.Start("explorer.exe", Path.GetDirectoryName(_profiles.CurrentPath) ?? "Profiles"); } catch { } };
            _dashLayout.Controls.Add(grpProf, 0, 6);
            _dashLayout.RowCount = Math.Max(_dashLayout.RowCount, 7);
            _tabs.TabPages.Add(tabDash);

        }

        private static void AddPair(TabPage tab, string label, Control input, ref int y)
        {
            AddPair((Control)tab, label, input, ref y);
        }

        private static void AddPair(Control container, string label, Control input, ref int y)
        {
            var l = new Label { Text = label, Location = new Point(16, y + 4), AutoSize = true };
            input.Location = new Point(220, y); input.Width = 64;
            container.Controls.Add(l); container.Controls.Add(input);
            y += 36;
        }

        private void BuildKeyGrid()
        {
            gridKeys.Columns.Add(new DataGridViewTextBoxColumn { HeaderText = "VK (hex)", DataPropertyName = "KeyHex", Width = 64 });
            gridKeys.Columns.Add(new DataGridViewTextBoxColumn { HeaderText = "Preview", DataPropertyName = "KeyName", Width = 120 });
            var colC = new DataGridViewComboBoxColumn { HeaderText = "Xbox Control", DataPropertyName = "Control", DataSource = Enum.GetValues(typeof(Xbox360Control)) };
            gridKeys.Columns.Add(colC);
            gridKeys.Columns.Add(new DataGridViewButtonColumn { HeaderText = "Rebind", Text = "Bind", UseColumnTextForButtonValue = true, Width = 64 });
            gridKeys.CellClick += (s, e) =>
            {
                if (e.RowIndex >= 0 && e.ColumnIndex == 3)
                {
                    var vk = ((KeyRow)gridKeys.Rows[e.RowIndex].DataBoundItem).Vk;
                    _capturing = true; _captureTarget = $"K:{vk}";
                    gridKeys.Rows[e.RowIndex].Cells[3].Value = "Press key...";
                }
            };
        }

        private void BuildMouseGrid()
        {
            gridMouse.Columns.Add(new DataGridViewTextBoxColumn { HeaderText = "Mouse", DataPropertyName = "ButtonName", Width = 120 });
            var colC = new DataGridViewComboBoxColumn { HeaderText = "Xbox Control", DataPropertyName = "Control", DataSource = Enum.GetValues(typeof(Xbox360Control)) };
            gridMouse.Columns.Add(colC);
            gridMouse.Columns.Add(new DataGridViewTextBoxColumn { HeaderText = "Rapid Hz", DataPropertyName = "RapidHz", Width = 64 });
            gridMouse.Columns.Add(new DataGridViewTextBoxColumn { HeaderText = "Burst", DataPropertyName = "Burst", Width = 60 });
            gridMouse.CellEndEdit += (_, __) => PullUIToProfile();
        }

        private static bool IsWASD(int vk)
        {
            return vk == (int)Keys.W || vk == (int)Keys.A || vk == (int)Keys.S || vk == (int)Keys.D;
        }

        private void OnKey(int vk, bool down)
        {
            try {
                Logger.Info($"Key event: VK={vk} Down={down}");
                if (_outputSuspended) return;
                // --- suppression-proof overlay hotkey: detect via raw input before any mapping ---
                // Track modifier state
                if (vk == (int)Keys.ControlKey || vk == (int)Keys.LControlKey || vk == (int)Keys.RControlKey) _modCtrlDown = down;
                if (vk == (int)Keys.ShiftKey || vk == (int)Keys.LShiftKey || vk == (int)Keys.RShiftKey) _modShiftDown = down;
                if (vk == (int)Keys.Menu || vk == (int)Keys.LMenu || vk == (int)Keys.RMenu) _modAltDown = down;

                bool needCtrl = (_overlayHotkeyMods & MOD_CONTROL) != 0;
                bool needShift = (_overlayHotkeyMods & MOD_SHIFT) != 0;
                bool needAlt = (_overlayHotkeyMods & MOD_ALT) != 0;

                // Edge-triggered to avoid auto-repeat storms
                if (vk == _overlayToggleVk)
                {
                    if (!down) _overlayKeyPhysicalDown = false;
                    if (down && !_overlayKeyPhysicalDown &&
                        (!needCtrl || _modCtrlDown) &&
                        (!needShift || _modShiftDown) &&
                        (!needAlt || _modAltDown))
                    {
                        _overlayKeyPhysicalDown = true;
                        if (ShouldToggle()) { ToggleOverlayVisible(); }
                        // keep _overlayKeyPhysicalDown true until key-up to prevent key-repeat flicker
                        return;
                    }
                }
                if (_capturing)
                {
                    if (_captureTarget.StartsWith("K:"))
                    {
                        var row = gridKeys.SelectedRows.Count > 0 ? gridKeys.SelectedRows[0] : null;
                        if (row != null)
                        {
                            row.Cells[0].Value = $"0x{vk:X2}";
                            row.Cells[1].Value = ((Keys)vk).ToString();
                            ((KeyRow)row.DataBoundItem).Vk = vk;
                            PullUIToProfile();
                        }
                        _capturing = false; _captureTarget = "";
                        return;
                    }
                }

                _mapper.UpdateKey(vk, down);

                // Intercept WASD -> Left Stick if enabled
                if (_profiles.Current.WasdToLeftStick && IsWASD(vk))
                {
                    if (_mode == InputMode.ControllerOutput)
                    {
                        var (lx, ly) = _mapper.WasdToLeftStick();
                        _pad.SetLeftStick(lx, ly);
                    }
                    return;
                }

                if (_mode != InputMode.ControllerOutput) return;

                if (_profiles.Current.KeyMap.TryGetValue(vk, out var control))
                {
                    if (ControllerKeyMapManager.TryGetButton(control, out var btn))
                    {
                        if (down && TryGetRapid(control, out var rf)) _macros.StartRapid(btn, rf.RateHz, rf.Burst);
                        else if (!down) _macros.StopRapid(btn);
                        _pad.SetButton(btn, down);
                        return;
                    }

                    switch (control)
                    {
                        case Xbox360Control.LeftTrigger: _pad.SetTrigger(false, down ? (byte)255 : (byte)0); break;
                        case Xbox360Control.RightTrigger: _pad.SetTrigger(true, down ? (byte)255 : (byte)0); break;
                        case Xbox360Control.DpadUp: _dUp = down; break;
                        case Xbox360Control.DpadDown: _dDown = down; break;
                        case Xbox360Control.DpadLeft: _dLeft = down; break;
                        case Xbox360Control.DpadRight: _dRight = down; break;
                    }
                    _pad.SetDpad(_dUp, _dDown, _dLeft, _dRight);
                }
            } catch (Exception ex) { Logger.Error("OnKey error", ex); AddError($"OnKey: {ex.Message}"); }
        }

        private void OnMouseButton(MouseInput b, bool down)
        {
            try {
                Logger.Info($"Mouse button: {b} Down={down}");
                if (_outputSuspended) return;

                // If we are in capture mode for mouse buttons, ignore toggling logic so the binding can be captured
                if (_capturing && _captureTarget.StartsWith("M:")) { /* binding via grid */ return; }

                // Allow toggling the current input mode using the middle mouse button
                // Middle-click toggle uses a small state machine: 
                // - mark on press, accumulate movement while pressed
                // - on release, toggle only if recent wheel is quiet and movement while held is tiny
                if (b == MouseInput.Middle && _middleToggleEnabled)
                {
                    if (down)
                    {
                        _midDownActive = true;
                        _midDownTick = Environment.TickCount64;
                        _midMoveAccum = 0;
                    }
                    else
                    {
                        long now = Environment.TickCount64;
                        const long wheelQuietMs = 150;
                        const long debounceMs = 250;
                        const int moveThresh = 6;   // sum of |dx|+|dy| while held

                        if (_midDownActive)
                        {
                            _midDownActive = false;
                            if (now - _lastWheelTick >= wheelQuietMs &&
                                now - _lastToggleTick >= debounceMs &&
                                _midMoveAccum <= moveThresh)
                            {
                                _lastToggleTick = now;
                                ToggleMaster();
                            }
                        }
                    }
                    return;
                }

                // Only map mouse buttons to controller output when in controller-output mode
                if (_mode != InputMode.ControllerOutput) return;

                if (_profiles.Current.MouseMap.TryGetValue(b, out var control))
                {
                    if (ControllerKeyMapManager.TryGetButton(control, out var btn))
                    {
                        if (down && TryGetRapid(control, out var rf)) _macros.StartRapid(btn, rf.RateHz, rf.Burst);
                        else if (!down) _macros.StopRapid(btn);
                        _pad.SetButton(btn, down);
                        return;
                    }

                    if (control == Xbox360Control.LeftTrigger) _pad.SetTrigger(false, down ? (byte)255 : (byte)0);
                    if (control == Xbox360Control.RightTrigger) _pad.SetTrigger(true, down ? (byte)255 : (byte)0);
                    if (control == Xbox360Control.RightStick) _pad.SetButton(Xbox360Button.RightThumb, down);
                }
            } catch (Exception ex) { Logger.Error("OnMouseButton error", ex); AddError($"OnMouseButton: {ex.Message}"); }
        }

        private void OnMouseMove(int dx, int dy)
        {
            try {
                Logger.Info($"Mouse move: dx={dx} dy={dy}");
                if (_outputSuspended) return;


                if (_midDownActive) { _midMoveAccum += Math.Abs(dx) + Math.Abs(dy); }
                _lastMouseMoveUtc = DateTime.UtcNow;
                _tele.RawDx += dx; _tele.RawDy += dy;
                if (_mode != InputMode.ControllerOutput) return;

                var (sx, sy) = _mapper.MouseToRightStick(dx, dy);
                _pad.SetRightStick(sx, sy);

                var (lx, ly) = _mapper.WasdToLeftStick();
                _pad.SetLeftStick(lx, ly);

                _tele.StickRX = sx; _tele.StickRY = sy;
            } catch (Exception ex) { Logger.Error("OnMouseMove error", ex); AddError($"OnMouseMove: {ex.Message}"); }
        }

        private void OnWheel(int delta)
        {
            try {
                Logger.Info($"Mouse wheel: delta={delta}");
                if (_outputSuspended) return;


                _lastWheelTick = Environment.TickCount64;
                if (_mode != InputMode.ControllerOutput) return;

                if (delta > 0 && _profiles.Current.MouseMap.TryGetValue(MouseInput.ScrollUp, out var cu))
                {
                    if (ControllerKeyMapManager.TryGetButton(cu, out var btn)) { _pad.SetButton(btn, true); _pad.SetButton(btn, false); }
                }
                else if (delta < 0 && _profiles.Current.MouseMap.TryGetValue(MouseInput.ScrollDown, out var cd))
                {
                    if (ControllerKeyMapManager.TryGetButton(cd, out var btn)) { _pad.SetButton(btn, true); _pad.SetButton(btn, false); }
                }
            } catch (Exception ex) { Logger.Error("OnWheel error", ex); AddError($"OnWheel: {ex.Message}"); }
        }

        private void UpdateVisualizer()
        {
            try
            {
                short lx = 0, ly = 0, rx = 0, ry = 0; byte lt = 0, rt = 0;
                bool a = false, b = false, x = false, y = false, lb = false, rb = false, back = false, start = false, l3 = false, r3 = false, dup = false, ddown = false, dleft = false, dright = false;

                if (_mode == InputMode.ControllerPassthrough &&
                    TryReadXInputSnapshot(_detector?.Index ?? 0,
                                          out lx, out ly, out rx, out ry, out lt, out rt,
                                          out a, out b, out x, out y, out lb, out rb, out back, out start, out l3, out r3,
                                          out dup, out ddown, out dleft, out dright))
                {
                    // physical snapshot used
                }
                else if (_mode == InputMode.ControllerOutput)
                {
                    var s = _pad.GetSnapshot();
                    lx = s.LX; ly = s.LY; rx = s.RX; ry = s.RY;
                    lt = s.LT; rt = s.RT;
                    a = s.A; b = s.B; x = s.X; y = s.Y; lb = s.LB; rb = s.RB; back = s.Back; start = s.Start; l3 = s.L3; r3 = s.R3;
                    dup = s.DUp; ddown = s.DDown; dleft = s.DLeft; dright = s.DRight;
                }
                else
                {
                    rx = _tele.StickRX;
                    ry = _tele.StickRY;
                }

                _viz.SetState(lx, ly, rx, ry, lt, rt, a, b, x, y, lb, rb, back, start, l3, r3, dup, ddown, dleft, dright);
            }
            catch { }
        }
        /// <summary>Read XInput snapshot for the overlay visual. Returns false if device not connected.</summary>
        private bool TryReadXInputSnapshot(int playerIndex,
                                           out short lx, out short ly, out short rx, out short ry,
                                           out byte lt, out byte rt,
                                           out bool a, out bool b, out bool x, out bool y,
                                           out bool lb, out bool rb, out bool back, out bool start, out bool l3, out bool r3,
                                           out bool dup, out bool ddown, out bool dleft, out bool dright)
        {
            lx = ly = rx = ry = 0; lt = rt = 0; a = b = x = y = lb = rb = back = start = l3 = r3 = dup = ddown = dleft = dright = false;
            try
            {
                XINPUT_STATE s;
                uint res;
                try { res = XInputGetState14((uint)playerIndex, out s); }
                catch (DllNotFoundException) { res = XInputGetState13((uint)playerIndex, out s); }
                if (res != ERROR_SUCCESS) return false;

                var gp = s.Gamepad;
                lx = gp.sThumbLX; ly = gp.sThumbLY; rx = gp.sThumbRX; ry = gp.sThumbRY;
                lt = gp.bLeftTrigger; rt = gp.bRightTrigger;

                const ushort DPAD_UP = 0x0001, DPAD_DOWN = 0x0002, DPAD_LEFT = 0x0004, DPAD_RIGHT = 0x0008,
                             START = 0x0010, BACK = 0x0020, LTHUMB = 0x0040, RTHUMB = 0x0080,
                             LBUT = 0x0100, RBUT = 0x0200, A_BTN = 0x1000, B_BTN = 0x2000, X_BTN = 0x4000, Y_BTN = 0x8000;

                a = (gp.wButtons & A_BTN) != 0;
                b = (gp.wButtons & B_BTN) != 0;
                x = (gp.wButtons & X_BTN) != 0;
                y = (gp.wButtons & Y_BTN) != 0;
                lb = (gp.wButtons & LBUT) != 0;
                rb = (gp.wButtons & RBUT) != 0;
                back = (gp.wButtons & BACK) != 0;
                start = (gp.wButtons & START) != 0;
                l3 = (gp.wButtons & LTHUMB) != 0;
                r3 = (gp.wButtons & RTHUMB) != 0;
                dup = (gp.wButtons & DPAD_UP) != 0;
                ddown = (gp.wButtons & DPAD_DOWN) != 0;
                dleft = (gp.wButtons & DPAD_LEFT) != 0;
                dright = (gp.wButtons & DPAD_RIGHT) != 0;
                return true;
            }
            catch { return false; }
        }



        private bool TryGetXInputSnapshot(out short lx, out short ly, out short rx, out short ry, out byte lt, out byte rt,
                                          out bool a, out bool b, out bool x, out bool y, out bool lb, out bool rb,
                                          out bool back, out bool start, out bool l3, out bool r3, out bool dup, out bool ddown, out bool dleft, out bool dright)
        {
            lx = ly = rx = ry = 0; lt = rt = 0;
            a = b = x = y = lb = rb = back = start = l3 = r3 = dup = ddown = dleft = dright = false;
            XINPUT_STATE s;
            for (uint i = 0; i < 4; i++)
            {
                try
                {
                    if (XInputGetState14(i, out s) != ERROR_SUCCESS)
                    {
                        try { if (XInputGetState13(i, out s) != ERROR_SUCCESS) continue; } catch { continue; }
                    }
                    // Map sticks/triggers
                    lx = s.Gamepad.sThumbLX; ly = s.Gamepad.sThumbLY;
                    rx = s.Gamepad.sThumbRX; ry = s.Gamepad.sThumbRY;
                    lt = s.Gamepad.bLeftTrigger; rt = s.Gamepad.bRightTrigger;
                    // Map buttons
                    ushort w = s.Gamepad.wButtons;
                    const ushort D_UP = 0x0001, D_DOWN = 0x0002, D_LEFT = 0x0004, D_RIGHT = 0x0008,
                                 START = 0x0010, BACK = 0x0020, LTHUMB = 0x0040, RTHUMB = 0x0080,
                                 LBUT = 0x0100, RBUT = 0x0200, A_BTN = 0x1000, B_BTN = 0x2000, X_BTN = 0x4000, Y_BTN = 0x8000;
                    dup = (w & D_UP) != 0;
                    ddown = (w & D_DOWN) != 0;
                    dleft = (w & D_LEFT) != 0;
                    dright = (w & D_RIGHT) != 0;
                    start = (w & START) != 0;
                    back = (w & BACK) != 0;
                    l3 = (w & LTHUMB) != 0;
                    r3 = (w & RTHUMB) != 0;
                    lb = (w & LBUT) != 0;
                    rb = (w & RBUT) != 0;
                    a = (w & A_BTN) != 0;
                    b = (w & B_BTN) != 0;
                    x = (w & X_BTN) != 0;
                    y = (w & Y_BTN) != 0;
                    return true;
                }
                catch { }
            }
            return false;
        }
        private bool TryGetRapid(Xbox360Control control, out RapidFireConfig cfg)
                    => _profiles.Current.RapidFire.TryGetValue(control, out cfg!);

        private async Task StartFigure8()
        {
            SuspendRawInput("Figure8");
            StopFigure8();
            _figCts = new CancellationTokenSource();
            var fig = new FigureEightDriver();
            await Task.Run(async () =>
            {
                var sw = System.Diagnostics.Stopwatch.StartNew();
                while (!_figCts.IsCancellationRequested)
                {
                    double t = sw.Elapsed.TotalSeconds;
                    var (dx, dy) = fig.At(t);
                    var (sx, sy) = _mapper.MouseToRightStick(dx, dy);
                    _pad.SetRightStick(sx, sy);
                    await Task.Delay(5, _figCts.Token);
                }
            }, _figCts.Token);
        }

        private void StopFigure8()
        {
            ResumeRawInput("Figure8");
            try { _figCts?.Cancel(); _figCts?.Dispose(); } catch { }
            _figCts = null;
        }

        private async Task RunAutoTune(int seconds)
        {
            _autoTune.Enabled = false;
            _tuneCts = new CancellationTokenSource();
            try
            {
                var tuner = new AutoTuner();
                var res = await tuner.RunAsync(_mapper.Curve, seconds, _tuneCts.Token);
                _mapper.Curve.Sensitivity = res.Sens;
                _mapper.Curve.Expo = res.Expo;
                _mapper.Curve.AntiDeadzone = res.ADZ;
                ApplyCurvesToUI();
                PullUIToProfile(); _profiles.Save();
                MessageBox.Show($"Auto-tune done.\nSens={res.Sens:F2} Expo={res.Expo:F2} ADZ={res.ADZ:F2}", "Auto-Tune");
            }
            catch (OperationCanceledException) { }
            catch (Exception ex) { Logger.Error("AutoTune failed", ex); }
            finally { _autoTune.Enabled = true; _tuneCts?.Dispose(); _tuneCts = null; }
        }

        private void ToggleMaster()
        {
            try { _modes.ToggleNext(includePassthrough: true); } catch { }
        }


        private void ToggleSuppress()
        {
            LowLevelHooks.Suppress = !LowLevelHooks.Suppress;
            _suppressGuard = true; _xpassGuard = true;
            _suppressChk.Checked = LowLevelHooks.Suppress;
            _xpassGuard = false; _suppressGuard = false;
            UpdateStatus();
            try
            {
                _tray.BalloonTipTitle = "WootMouseRemap";
                _tray.BalloonTipText = $"(merged) {(LowLevelHooks.Suppress ? "ON" : "OFF")}";
                _tray.ShowBalloonTip(1000);
            }
            catch { }
        }




        private void ToggleOverlayVisible()
        {
            try
            {
                if (Visible && WindowState != FormWindowState.Minimized)
                {
                    // Hide overlay
                    Hide();
                    ShowInTaskbar = false;
                    _tray.Text = "WootMouseRemap (Hidden)";
                }
                else
                {
                    // Show and bring overlay to front, even above fullscreen games
                    ShowInTaskbar = true;
                    if (WindowState == FormWindowState.Minimized)
                        WindowState = FormWindowState.Normal;
                    Show();
                    TopMost = true;
                    BringToFront();
                    Activate();
                    Focus();
                    // Force topmost using Win32 API
                    SetWindowPos(this.Handle, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
                    _tray.Text = "WootMouseRemap";
                }
            }
            catch (Exception ex) { AddError($"Overlay toggle error: {ex.Message}"); }
        }

        private static bool IsStartupEnabled()
        {
            using var k = Registry.CurrentUser.OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Run", false);
            return k?.GetValue("WootMouseRemap") is string s && !string.IsNullOrWhiteSpace(s);
        }
        private static void SetStartupEnabled(bool enabled)
        {
            using var k = Registry.CurrentUser.OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Run", true);
            if (k == null) return;
            if (enabled) k.SetValue("WootMouseRemap", Application.ExecutablePath);
            else k.DeleteValue("WootMouseRemap", false);
        }


        private bool AnyXInputActivityInLastSeconds(int seconds)
        {
            try
            {
                XINPUT_STATE s = default;
                bool activeNow = false;
                for (uint i = 0; i < 4; i++)
                {
                    bool ok = false;
                    try { ok = XInputGetState14(i, out s) == ERROR_SUCCESS; } catch (DllNotFoundException) { ok = false; } catch { }
                    if (!ok) { try { ok = XInputGetState13(i, out s) == ERROR_SUCCESS; } catch { ok = false; } }
                    if (ok)
                    {
                        if (s.Gamepad.wButtons != 0 || s.Gamepad.bLeftTrigger != 0 || s.Gamepad.bRightTrigger != 0 ||
                            Math.Abs(s.Gamepad.sThumbLX) > 4000 || Math.Abs(s.Gamepad.sThumbLY) > 4000 ||
                            Math.Abs(s.Gamepad.sThumbRX) > 4000 || Math.Abs(s.Gamepad.sThumbRY) > 4000)
                        {
                            _lastControllerActivity = DateTime.UtcNow;
                            activeNow = true;
                            break;
                        }
                    }
                }
                if (activeNow) return true;
                return (DateTime.UtcNow - _lastControllerActivity) < TimeSpan.FromSeconds(seconds);
            }
            catch { return false; }
        }
        private static void SetTextIfChanged(Control c, string text) { if (!string.Equals(c.Text, text, StringComparison.Ordinal)) c.Text = text; }
        private void UpdateStatus()
        {
            try {
                _tele.Suppressing = LowLevelHooks.Suppress;
                _tele.ViGEmConnected = _pad.IsConnected;
                _tele.ProfileName = _profiles.Current.Name;

                var idleMs = (DateTime.UtcNow - _lastMouseMoveUtc).TotalMilliseconds;
                bool liftoff = idleMs > 18;
                
                string controllerInfo = "";
                if (_physControllerPresent)
                {
                    int activeIndex = _detector?.Index ?? 0;
                    controllerInfo = $" | Controller: P{activeIndex + 1} Detected";
                }
                else
                {
                    controllerInfo = " | Controller: None";
                }
                
                _status.Text = $"Mode: {_mode} | ViGEm: {(_pad.IsConnected ? "OK" : "Not Connected")} | " +
                               $"Suppression: {(LowLevelHooks.Suppress ? "ON" : "OFF")} | RX/RY: {_tele.StickRX}/{_tele.StickRY} | Profile: {_tele.ProfileName} | " +
                               $"DPI: {_profiles.Current.MouseDpi} (rec. 1600–3200) | Liftoff: {(liftoff ? "YES" : "no")}";
                _status.Text += $" | {BUILD_TAG}";
                _status.Text += controllerInfo;
                
                if (_mode == InputMode.ControllerPassthrough && _xpass.IsRunning)
                {
                    _status.Text += " (Passthrough Active)";
                }
                
                _status.ForeColor = _physControllerPresent ? Color.LimeGreen : Color.IndianRed;
                _tray.Text = $"WootMouseRemap - {_mode}";
                _suppressChk.Enabled = (_mode == InputMode.ControllerOutput);
                if (_suppressChk.Checked != LowLevelHooks.Suppress) { _suppressGuard = true; _suppressChk.Checked = LowLevelHooks.Suppress; _suppressGuard = false; }

                _ctlrDot.Invalidate();
                _ctlrTip.SetToolTip(_ctlrDot, _physControllerPresent ? $"Controller P{(_detector?.Index ?? 0) + 1} detected" : "No controller");

                // Draw errors in status
                var errors = GetRecentErrors();
                if (errors.Count > 0)
                {
                    _status.Text += "\nErrors:";
                    foreach (var err in errors) _status.Text += $"\n  {err}";
                }
            } catch (Exception ex) { Logger.Error("UpdateStatus error", ex); AddError($"UpdateStatus: {ex.Message}"); }
        }

        // Optionally, override OnPaint to show errors in overlay
        protected override void OnPaint(PaintEventArgs e)
        {
            base.OnPaint(e);
            var errors = GetRecentErrors();
            if (errors.Count > 0)
            {
                var font = new Font(FontFamily.GenericSansSerif, 9, FontStyle.Bold);
                var brush = Brushes.Red;
                int y = 8;
                foreach (var err in errors)
                {
                    e.Graphics.DrawString(err, font, brush, 8, y);
                    y += 18;
                }
            }
        }

        private void ApplyCurvesFromUI()
        {
            var c = _mapper.Curve;
            c.Sensitivity = (float)nSens.Value / 100f;
            c.Expo = (float)nExpo.Value / 100f;
            c.AntiDeadzone = (float)nADZ.Value / 100f;
            c.EmaAlpha = (float)nEMA.Value / 100f;
            c.VelocityGain = (float)nVel.Value / 100f;
            c.JitterFloor = (float)nJit.Value / 100f;
            c.ScaleX = (float)nSX.Value / 100f;
            c.ScaleY = (float)nSY.Value / 100f;
            PullUIToProfile();
        }

        private void ApplyCurvesToUI()
        {
            var c = _mapper.Curve;
            nSens.Value = (decimal)(c.Sensitivity * 100);
            nExpo.Value = (decimal)(c.Expo * 100);
            nADZ.Value = (decimal)(c.AntiDeadzone * 100);
            nEMA.Value = (decimal)(c.EmaAlpha * 100);
            nVel.Value = (decimal)(c.VelocityGain * 100);
            nJit.Value = (decimal)(c.JitterFloor * 100);
            nSX.Value = (decimal)(c.ScaleX * 100);
            nSY.Value = (decimal)(c.ScaleY * 100);
        }

        private void ApplyProfileToUI()
        {
            // Curves
            var p = _profiles.Current.Curves;
            var c = _mapper.Curve;
            c.Sensitivity = p.Sensitivity;
            c.Expo = p.Expo;
            c.AntiDeadzone = p.AntiDeadzone;
            c.EmaAlpha = p.EmaAlpha;
            c.VelocityGain = p.VelocityGain;
            c.JitterFloor = p.JitterFloor;
            c.ScaleX = p.ScaleX;
            c.ScaleY = p.ScaleY;
            ApplyCurvesToUI();

            // Grids
            var keyRows = _profiles.Current.KeyMap
                .Select(kv => new KeyRow { Vk = kv.Key, KeyHex = $"0x{kv.Key:X2}", KeyName = ((Keys)kv.Key).ToString(), Control = kv.Value })
                .OrderBy(r => r.KeyHex).ToList();
            gridKeys.DataSource = keyRows;

            var mouseRows = _profiles.Current.MouseMap
                .Select(kv => new MouseRow
                {
                    Button = kv.Key,
                    ButtonName = kv.Key.ToString(),
                    Control = kv.Value,
                    RapidHz = _profiles.Current.RapidFire.TryGetValue(kv.Value, out var rf) ? rf.RateHz : 0,
                    Burst = _profiles.Current.RapidFire.TryGetValue(kv.Value, out var rf2) ? rf2.Burst : 0
                })
                .ToList();
            gridMouse.DataSource = mouseRows;

            // Profiles list refresh
            lstProfiles.Items.Clear();
            lstProfiles.Items.AddRange(_profiles.ListProfiles().ToArray());

            // Overlay hotkey label
            var vk = _profiles.Current.OverlayToggleVk != 0 ? _profiles.Current.OverlayToggleVk : 0xDC;
            _overlayHotkeyLbl.Text = $"Overlay toggle: {((_overlayHotkeyMods & MOD_CONTROL) != 0 ? "Ctrl+" : "")}{((_overlayHotkeyMods & MOD_SHIFT) != 0 ? "Shift+" : "")}{((_overlayHotkeyMods & MOD_ALT) != 0 ? "Alt+" : "")}{(Keys)vk} (0x{vk:X2})";
        }

        private void PullUIToProfile()
        {
            var p = _profiles.Current;
            // curves
            p.Curves.Sensitivity = (float)nSens.Value / 100f;
            p.Curves.Expo = (float)nExpo.Value / 100f;
            p.Curves.AntiDeadzone = (float)nADZ.Value / 100f;
            p.Curves.EmaAlpha = (float)nEMA.Value / 100f;
            p.Curves.VelocityGain = (float)nVel.Value / 100f;
            p.Curves.JitterFloor = (float)nJit.Value / 100f;
            p.Curves.ScaleX = (float)nSX.Value / 100f;
            p.Curves.ScaleY = (float)nSY.Value / 100f;
            p.MouseDpi = (int)nDpi.Value;
            nDpi.Value = _profiles.Current.MouseDpi;

            // key map
            p.KeyMap = ((System.Collections.Generic.List<KeyRow>)gridKeys.DataSource).ToDictionary(r => r.Vk, r => r.Control);

            // mouse map + rapid
            p.MouseMap = ((System.Collections.Generic.List<MouseRow>)gridMouse.DataSource).ToDictionary(r => r.Button, r => r.Control);
            p.RapidFire.Clear();
            foreach (var r in (System.Collections.Generic.List<MouseRow>)gridMouse.DataSource)
                if (r.RapidHz > 0 && ControllerKeyMapManager.TryGetButton(r.Control, out _))
                    p.RapidFire[r.Control] = new RapidFireConfig { RateHz = r.RapidHz, Burst = r.Burst };
        }

        private bool ShouldToggle() { return !_capturingOverlayKey; }

        private void OnModeChanged(InputMode oldMode, InputMode newMode)
        {
            Logger.Info($"Mode changed: {oldMode} -> {newMode}");
            if (InvokeRequired) { try { BeginInvoke(new Action(() => OnModeChanged(oldMode, newMode))); } catch { } return; }
            _mode = newMode;
            try
            {
                // Stop passthrough unless explicitly in passthrough
                if (newMode != InputMode.ControllerPassthrough)
                {
                    try { _xpass.Stop(); } catch { }
                }
                if (newMode == InputMode.ControllerOutput)
                {
                    LowLevelHooks.Suppress = true;
                    _suppressGuard = true; _xpassGuard = true;
                    _suppressChk.Checked = true;
                    _xpassGuard = false; _suppressGuard = false;
                    _xpassGuard = true; _xinputEnable.Checked = false; _xpassGuard = false;
                }
                else // ControllerPassthrough
                {
                    _pad.ResetAll();
                    LowLevelHooks.Suppress = false;
                    _suppressGuard = true; _xpassGuard = true;
                    _suppressChk.Checked = false;
                    _xpassGuard = false; _suppressGuard = false;
                    try
                    {
                        // Ensure ViGEm virtual controller is connected before passthrough
                        if (!_pad.IsConnected) { try { _pad.Connect(); } catch { AddError("ViGEm connect failed"); } }
                        // Always stop and restart passthrough to ensure thread is fresh and index is set
                        _xpass.Stop();

                        // Get the current active controller index from the detector, default to P2 (index 1)
                        int activeIndex = _detector?.Index ?? 1;
                        bool hasController = _detector?.Connected ?? false;
                        
                        // If no specific controller is detected, default to P2 (index 1)
                        if (!hasController)
                        {
                            activeIndex = 1;
                            hasController = XInputHelper.IsConnected(activeIndex);
                        }
                        
                        // Set the correct player index based on where the physical controller is connected
                        _xpass.SetPlayerIndex(activeIndex);
                        
                        // Only start passthrough if there's actually a controller connected
                        if (hasController)
                        {
                            // Ensure the virtual controller is connected before starting passthrough
                            if (!_pad.IsConnected) { try { _pad.Connect(); } catch { AddError("ViGEm connect failed (retry)"); } }
                            _xpass.Start();
                        }
                        else
                        {
                            // No physical controller - switch back to Controller Output
                            _modes.Apply(InputMode.ControllerOutput);
                            try
                            {
                                _tray.BalloonTipTitle = "WootMouseRemap";
                                _tray.BalloonTipText = "No controller detected — switched to Play (Controller Output)";
                                _tray.ShowBalloonTip(1500);
                            }
                            catch { }
                            return; // Early return to avoid setting xinputEnable.Checked
                        }
                    }
                    catch (Exception ex) { AddError($"Passthrough start failed: {ex.Message}"); }
                    _xpassGuard = true; _xinputEnable.Checked = true; _xpassGuard = false;
                }
            }
            catch (Exception ex) { AddError($"OnModeChanged error: {ex.Message}"); }
            UpdateStatus();
            UpdateToggleButtonText();
            try
            {
                _tray.Text = $"WootMouseRemap - {newMode}";
                _ctlrTip.SetToolTip(_ctlrDot, _physControllerPresent ? "Controller detected" : "No controller");
            }
            catch { }
            try { File.WriteAllText("mode.json", ((int)newMode).ToString()); } catch { }
        }
        private void UpdateToggleButtonText()
        {
            _toggleMode.Text = "Toggle (Play/Controller)";
        }


        private bool falseReturn() => false;

        private void RegisterOverlayHotkey(int vk)
        {
            try { UnregisterHotKey(Handle, HOTKEY_TOGGLE_MASTER); } catch { }
            _overlayHotkeyRegisteredVk = vk;
            _overlayToggleVk = vk;
            if (vk == 0) { _overlayHotkeyLbl.Text = "Hotkey: (disabled)"; return; }
            _overlayHotkeyLbl.Text = "Overlay toggle: " + HotkeyLabel(_overlayHotkeyMods, vk);
            if (_overlayHotkeyMods != 0)
            {
                try { RegisterHotKey(Handle, HOTKEY_TOGGLE_MASTER, _overlayHotkeyMods, vk); } catch { }
            }
        }

        private void RebindOverlayHotkeyFromProfile()
        {
            var vk = _profiles.Current.OverlayToggleVk;
            // removed hard-coded default VK_OEM_5 (\) fallback
            RegisterOverlayHotkey(vk);
        }

        // ===== rows =====
        private sealed class KeyRow
        {
            public int Vk { get; set; }
            public string KeyHex { get; set; } = "";
            public string KeyName { get; set; } = "";
            public Xbox360Control Control { get; set; }
        }
        private sealed class MouseRow
        {
            public MouseInput Button { get; set; }
            public string ButtonName { get; set; } = "";
            public Xbox360Control Control { get; set; }
            public double RapidHz { get; set; }
            public int Burst { get; set; }
        }

        // ===== Win32 message pump & handle lifecycle =====

        private static string HotkeyLabel(uint mods, int vk)
        {
            if (vk == 0) return "Hotkey: (disabled)";
            List<string> parts = new();
            if ((mods & MOD_CONTROL) != 0) parts.Add("Ctrl");
            if ((mods & MOD_SHIFT) != 0) parts.Add("Shift");
            if ((mods & MOD_ALT) != 0) parts.Add("Alt");
            string key = ((Keys)vk).ToString();
            parts.Add(key);
            return "Hotkey: " + string.Join("+", parts);
        }

        private void RegisterAllHotkeysFromProfile()
        {
            // Unregister any legacy ids then register the single master hotkey
            try { UnregisterHotKey(Handle, HOTKEY_TOGGLE_MASTER); } catch { }
            try { UnregisterHotKey(Handle, HOTKEY_PANIC); } catch { }
            // Clean old ids if they still exist in running builds
            try { UnregisterHotKey(Handle, HOTKEY_TOGGLE_MASTER); } catch { }

            var p = _profiles.Current;
            if (p.ModeToggleVk != 0)
            {
                try { RegisterHotKey(Handle, HOTKEY_TOGGLE_MASTER, p.ModeToggleMods, p.ModeToggleVk); } catch { }
            }

            // Always-on safety: Ctrl+Alt+Delete to force Desktop (unsuppress)
            try { RegisterHotKey(Handle, HOTKEY_PANIC, PANIC_MODS, (int)PANIC_KEY); } catch { }
            _modeHotkeyLbl.Text = HotkeyLabel(p.ModeToggleMods, p.ModeToggleVk) + " (master)";
            _overlayHotkeyLbl.Text = HotkeyLabel(p.OverlayToggleMods, p.OverlayToggleVk);
            _suppressHotkeyLbl.Text = "";
        }


        protected override void WndProc(ref Message m)
        {
            try
            {
                if (m.Msg == WM_DEVICECHANGE)
                {
                    var p = AnyXInputControllerPresent();
                    if (p != _physControllerPresent) { _physControllerPresent = p; UpdateStatus(); }
                }

                base.WndProc(ref m);

                const int WM_HOTKEY = 0x0312;
                if (m.Msg == WM_HOTKEY)
                {
                    int id = m.WParam.ToInt32();
                    if (id == HOTKEY_TOGGLE_MASTER) { if (ShouldToggle()) ToggleMaster(); }
                    else if (id == HOTKEY_PANIC)
                    {
                        try { _modes.Apply(InputMode.ControllerOutput); } catch { }
                        try { _tray.BalloonTipTitle = "WootMouseRemap"; _tray.BalloonTipText = "Panic: switched to Play (Controller Output)"; _tray.ShowBalloonTip(1200); } catch { }
                    }
                }

            }
            catch { }
        }

        protected override void OnHandleCreated(EventArgs e)
        {
            base.OnHandleCreated(e);
            try { RegisterAllHotkeysFromProfile(); } catch { }
        }


        protected override void OnHandleDestroyed(EventArgs e)
        {
            try { UnregisterHotKey(Handle, HOTKEY_TOGGLE_MASTER); } catch { }
            try { UnregisterHotKey(Handle, HOTKEY_PANIC); } catch { }
            base.OnHandleDestroyed(e);
        }


        protected override void OnFormClosing(FormClosingEventArgs e)
        {
            _tray.Visible = false;
            try { UnregisterHotKey(Handle, HOTKEY_TOGGLE_MASTER); } catch { }
            try { UnregisterHotKey(Handle, HOTKEY_PANIC); } catch { }
            StopFigure8();
            try { _macros.Dispose(); } catch { }
            base.OnFormClosing(e);
        }

        private void ShowTips()
        {
            var msg =
@"SUPER IN-DEPTH DIRECTIONS AND TIPS\n\n" +
@"--- Getting Started ---\n" +
@"1. Connect your controller and mouse.\n" +
@"2. Launch WootMouseRemap.\n" +
@"3. The Dashboard tab shows your current mode, controller status, and mappings.\n" +
@"4. Use the 'Toggle (Desktop/Play)' button or middle mouse button to switch between Desktop (Mouse/Keyboard) and Play (Controller Output) modes.\n" +
@"5. Controller Passthrough mode mirrors your physical controller to a virtual Xbox 360 controller (ViGEm).\n\n" +
@"--- Modes ---\n" +
@"- Desktop: Mouse and keyboard act normally.\n" +
@"- Play: Mouse and keyboard are mapped to a virtual controller.\n" +
@"- Controller Passthrough: Physical controller input is mirrored to the virtual controller (defaults to P2).\n\n" +
@"--- Hotkeys ---\n" +
@"- Overlay Toggle: Set your own hotkey to show/hide the overlay.\n" +
@"- Mode Toggle: Switch between Desktop/Play/Controller Passthrough.\n" +
@"- Suppress: Toggle OS input suppression (prevents dual input).\n" +
@"- Panic: Ctrl+Alt+Delete always switches to Desktop mode and disables suppression.\n\n" +
@"--- Mapping Controls ---\n" +
@"- Keyboard: Bind keys to controller buttons using the Mappings grid.\n" +
@"- Mouse: Bind mouse buttons and wheel to controller buttons.\n" +
@"- Rapid Fire: Set Hz and burst for rapid-fire on mapped buttons.\n\n" +
@"--- Curves & Sensitivity ---\n" +
@"- Adjust sensitivity, expo, anti-deadzone, smoothing, and more in the Curves section.\n" +
@"- DPI: Set your mouse DPI for accurate scaling (recommended: 1600–3200).\n\n" +
@"--- Profiles ---\n" +
@"- Save, load, clone, and delete profiles.\n" +
@"- Each profile stores mappings, curves, and hotkeys.\n\n" +
@"--- Advanced Tips ---\n" +
@"- Use HidHide to hide your physical controller from games to prevent double input.\n" +
@"- The visualizer shows real-time stick, trigger, and button states.\n" +
@"- Figure-8 and Auto-Tune tools help calibrate your mouse-to-stick mapping.\n" +
@"- No-motion watchdog: If you lift the mouse, right stick is zeroed to prevent drift.\n" +
@"- Diagonal smoothing eliminates stutter at stick diagonals.\n\n" +
@"--- Troubleshooting ---\n" +
@"- If ViGEm is not connected, check your ViGEmBus installation.\n" +
@"- If you see double input, use HidHide.\n" +
@"- Logs are saved in the Logs folder.\n" +
@"- For fatal errors, see Logs/fatal.txt.\n\n" +
@"--- Quick Reference ---\n" +
@"- Toggle Mode: F8 or Middle Mouse\n" +
@"- Suppress: (merged) Ctrl+F9\n" +
@"- Panic: Ctrl+Alt+Delete\n" +
@"- Overlay: Set your own hotkey\n\n" +
@"--- RIPS ---\n" +
@"- If you need to reset everything, delete the Profiles folder.\n" +
@"- For advanced diagnostics, check the Logs folder.\n" +
@"- If you break your mappings, use the 'New' or 'Clone' profile buttons to start fresh.\n\n" +
@"For more help, see the README or ask in the community.";

            MessageBox.Show(this, msg, "SUPER DIRECTIONS & TIPS", MessageBoxButtons.OK, MessageBoxIcon.Information);
        }
        private void WireHiddenPassthroughBridge()
        {
            // Only hide the checkbox if needed, but do not hide the NumericUpDown.
            // _xinputEnable.Visible = false; // REMOVE THIS LINE to keep it visible in the UI
            _xinputEnable.AutoSize = true;
            _xinputEnable.TabStop = true;

            // When toggled programmatically, drive ModeController to Passthrough/MouseKeyboard.
            _xinputEnable.CheckedChanged += (_, __) =>
            {
                if (_xpassGuard) return;
                if (_xinputEnable.Checked)
                    _modes.Apply(InputMode.ControllerPassthrough);
                else
                    _modes.Apply(InputMode.ControllerOutput);
            };

            // Mirror the hidden checkbox with the current mode so state never drifts.
            _modes.ModeChanged += mode =>
            {
                _xpassGuard = true;
                _xinputEnable.Checked = (mode == InputMode.ControllerPassthrough);
                _xpassGuard = false;
            };
        }
    }
}